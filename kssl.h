// kssl.h: definitions for the Keyless SSL protocol
//
// Copyright (c) 2013-2014 CloudFlare, Inc.

#ifndef INCLUDED_KSSL
#define INCLUDED_KSSL 1

#define KSSL_HEADER_SIZE (sizeof(unsigned char) + sizeof(unsigned char) + sizeof(unsigned short) + sizeof(unsigned int))
#define KSSL_ITEM_HEADER_SIZE (sizeof(unsigned char) + sizeof(unsigned short))

typedef struct {
	unsigned char version_maj; // Protocol major version (see KSSL_VERSION_MAJ)
	unsigned char version_min; // Protocol minor version (see KSSL_VERSION_MIN)
	unsigned short length;     // Length of the payload
	unsigned int id;           // Unique ID generated by client for this operation
} kssl_header_st;

// The current KSSL protocol version
#define KSSL_VERSION_MAJ 0x01
#define KSSL_VERSION_MIN 0x00

// Possible item tags

typedef enum {
	KSSL_TAG_DIGEST    = 0x01, // An public key digest (see digest_public_key)
	KSSL_TAG_SNI       = 0x02, // Server name (optional)
	KSSL_TAG_CLIENT_IP = 0x03, // Client IP (4 bytes for IPv4, 16 for IPv6)
	KSSL_TAG_SKI       = 0x04, // Public key SKI
	KSSL_TAG_SERVER_IP = 0x05, // Server IP (4 bytes for IPv4, 16 for IPv6)
	KSSL_TAG_OPCODE    = 0x11, // Requested operation (one of KSSL_OP_*)
	KSSL_TAG_PAYLOAD   = 0x12, // Payload

	KSSL_TAG_PADDING   = 0x20, // Padding
} kssl_tag_et;

// Number of bytes to pad responses to

#define KSSL_PAD_TO 1024

// This structure stores the value of a given tag
typedef struct {
	unsigned char tag;     // Tag to identify contents of item
	unsigned short length; // Length of the item data
	unsigned char *data;   // The block of data to decrypt or sign
} kssl_item_st;

typedef enum {
	// Decrypt data encrypted using RSA with or without RSA_PKCS1_PADDING
	KSSL_OP_RSA_DECRYPT     = 0x01,
	KSSL_OP_RSA_DECRYPT_RAW = 0x08,

	// Sign data using RSA
	KSSL_OP_RSA_SIGN_MD5SHA1 = 0x02,
	KSSL_OP_RSA_SIGN_SHA1    = 0x03,
	KSSL_OP_RSA_SIGN_SHA224  = 0x04,
	KSSL_OP_RSA_SIGN_SHA256  = 0x05,
	KSSL_OP_RSA_SIGN_SHA384  = 0x06,
	KSSL_OP_RSA_SIGN_SHA512  = 0x07,

	// Sign data using RSA-PSS
#define KSSL_OP_RSA_PSS_MASK          0x30
	KSSL_OP_RSA_PSS_SIGN_SHA256 = 0x35,
	KSSL_OP_RSA_PSS_SIGN_SHA384 = 0x36,
	KSSL_OP_RSA_PSS_SIGN_SHA512 = 0x37,

	// Sign data using ECDSA
#define KSSL_OP_ECDSA_MASK           0x10
	KSSL_OP_ECDSA_SIGN_MD5SHA1 = 0x12,
	KSSL_OP_ECDSA_SIGN_SHA1    = 0x13,
	KSSL_OP_ECDSA_SIGN_SHA224  = 0x14,
	KSSL_OP_ECDSA_SIGN_SHA256  = 0x15,
	KSSL_OP_ECDSA_SIGN_SHA384  = 0x16,
	KSSL_OP_ECDSA_SIGN_SHA512  = 0x17,

	KSSL_OP_GET_CERTIFICATE = 0x20,

	// A test message which will be echoed with its payload with the
	// operation changed to OP_PONG
	KSSL_OP_PING = 0xF1,
	KSSL_OP_PONG = 0xF2,

	// A test message to verify a keyserver in an initialization state
	KSSL_OP_ACTIVATE = 0xF3,

	// Used to send a block of data back to the client (in response, for
	// example, to a KSSL_OP_RSA_DECRYPT)
	KSSL_OP_RESPONSE = 0xF0,
	KSSL_OP_ERROR    = 0xFF,
} kssl_opcode_et;

typedef enum {
	KSSL_ERROR_NONE              = 0x00,
	KSSL_ERROR_CRYPTO_FAILED     = 0x01,
	KSSL_ERROR_KEY_NOT_FOUND     = 0x02,
	KSSL_ERROR_READ              = 0x03,
	KSSL_ERROR_VERSION_MISMATCH  = 0x04,
	KSSL_ERROR_BAD_OPCODE        = 0x05,
	KSSL_ERROR_UNEXPECTED_OPCODE = 0x06,
	KSSL_ERROR_FORMAT            = 0x07,
	KSSL_ERROR_INTERNAL          = 0x08,
	KSSL_ERROR_CERT_NOT_FOUND    = 0x09,
} kssl_error_code_et;

#endif /* INCLUDED_KSSL */

// -*- mode: c;-*-
