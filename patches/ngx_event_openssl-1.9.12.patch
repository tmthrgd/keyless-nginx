diff -rupN a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
--- a/src/event/ngx_event_openssl.c	2016-02-25 01:23:23.000000000 +1030
+++ b/src/event/ngx_event_openssl.c	2016-03-28 19:56:56.841534666 +1030
@@ -13,6 +13,9 @@
 #define NGX_SSL_PASSWORD_BUFFER_SIZE  4096
 
 
+#include <ngx_keyless_module.h>
+
+
 typedef struct {
     ngx_uint_t  engine;   /* unsigned  engine:1; */
 } ngx_openssl_conf_t;
@@ -388,6 +391,35 @@ ngx_ssl_certificate(ngx_conf_t *cf, ngx_
 
     BIO_free(bio);
 
+    if (ngx_strncmp(key->data, "keyless:", sizeof("keyless:") - 1) == 0) {
+
+        u_char    *addr;
+        size_t    addr_len;
+        KEYLESS_CTX *ctx;
+
+        x509 = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);
+
+        addr = key->data + sizeof("keyless:") - 1;
+        addr_len = key->len - sizeof("keyless:") + 1;
+
+        ctx  = keyless_parse_and_create(cf->pool, x509, (const char *)addr, addr_len);
+
+        if (ctx == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "keyless_parse_and_create(\"%s\") failed", addr);
+            return NGX_ERROR;
+        }
+
+        if (keyless_attach_ssl_ctx(ssl->ctx, ctx) == 0) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "keyless_attach_ssl_ctx(\"%s\") failed", addr);
+            keyless_free(cf->pool, ctx);
+            return NGX_ERROR;
+        }
+
+        return NGX_OK;
+    }
+
     if (ngx_strncmp(key->data, "engine:", sizeof("engine:") - 1) == 0) {
 
 #ifndef OPENSSL_NO_ENGINE
@@ -1199,6 +1231,21 @@ ngx_ssl_handshake(ngx_connection_t *c)
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
 
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {
+        c->read->handler = ngx_ssl_handshake_handler;
+        c->write->handler = ngx_ssl_handshake_handler;
+
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
         }
