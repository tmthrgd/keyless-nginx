diff -rupN a/include/openssl/ssl.h b/include/openssl/ssl.h
--- a/include/openssl/ssl.h	2017-01-27 09:36:11.705726000 +1030
+++ b/include/openssl/ssl.h	2017-01-28 10:38:06.418645402 +1030
@@ -758,6 +758,17 @@ OPENSSL_EXPORT int SSL_CTX_use_certifica
  * on success and zero on failure. */
 OPENSSL_EXPORT int SSL_use_certificate(SSL *ssl, X509 *x509);
 
+/* SSL_CTX_use_raw_certificate sets |ctx|'s leaf certificate to |data|. It
+ * returns one on success and zero on failure. */
+OPENSSL_EXPORT int SSL_CTX_use_raw_certificate(SSL_CTX *ctx,
+                                               const uint8_t *data,
+                                               size_t len);
+
+/* SSL_use_raw_certificate sets |ssl|'s leaf certificate to |data|. It returns
+ * one on success and zero on failure. */
+OPENSSL_EXPORT int SSL_use_raw_certificate(SSL *ssl, const uint8_t *data,
+                                           size_t len);
+
 /* SSL_CTX_use_PrivateKey sets |ctx|'s private key to |pkey|. It returns one on
  * success and zero on failure. */
 OPENSSL_EXPORT int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
@@ -808,6 +819,18 @@ OPENSSL_EXPORT int SSL_CTX_add_extra_cha
  * and may release it freely. */
 OPENSSL_EXPORT int SSL_add1_chain_cert(SSL *ssl, X509 *x509);
 
+/* SSL_CTX_add_raw_chain_cert appends |data| to |ctx|'s certificate chain. It
+ * returns one on success and zero on failure. The caller retains ownership of
+ * |data| and may release it freely. */
+OPENSSL_EXPORT int SSL_CTX_add_raw_chain_cert(SSL_CTX *ctx,
+                                              const uint8_t *data, size_t len);
+
+/* SSL_add_raw_chain_cert appends |data| to |ctx|'s certificate chain. It
+ * returns one on success and zero on failure. The caller retains
+ * ownership of |data| and may release it freely. */
+OPENSSL_EXPORT int SSL_add_raw_chain_cert(SSL *ssl, const uint8_t *data,
+                                          size_t len);
+
 /* SSL_CTX_clear_chain_certs clears |ctx|'s certificate chain and returns
  * one. */
 OPENSSL_EXPORT int SSL_CTX_clear_chain_certs(SSL_CTX *ctx);
diff -rupN a/ssl/ssl_cert.c b/ssl/ssl_cert.c
--- a/ssl/ssl_cert.c	2017-01-28 10:13:07.442593000 +1030
+++ b/ssl/ssl_cert.c	2017-01-28 10:38:56.034647111 +1030
@@ -133,6 +133,8 @@
 #include "internal.h"
 
 
+static int ssl_cert_append_raw_cert(CERT *cert, CRYPTO_BUFFER *buffer);
+
 int SSL_get_ex_data_X509_STORE_CTX_idx(void) {
   /* The ex_data index to go from |X509_STORE_CTX| to |SSL| always uses the
    * reserved app_data slot. Before ex_data was introduced, app_data was used.
@@ -351,7 +353,10 @@ static int ssl_cert_append_cert(CERT *ce
   if (buffer == NULL) {
     return 0;
   }
+  return ssl_cert_append_raw_cert(cert, buffer);
+}
 
+static int ssl_cert_append_raw_cert(CERT *cert, CRYPTO_BUFFER *buffer) {
   if (cert->chain != NULL) {
     if (!sk_CRYPTO_BUFFER_push(cert->chain, buffer)) {
       CRYPTO_BUFFER_free(buffer);
@@ -392,6 +397,26 @@ static int ssl_cert_add1_chain_cert(CERT
   return 1;
 }
 
+static int ssl_cert_add_raw_chain_cert(CERT *cert, const uint8_t *data,
+                                       size_t len) {
+  if (data == NULL) {
+    OPENSSL_PUT_ERROR(SSL, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+
+  CRYPTO_BUFFER *buffer = CRYPTO_BUFFER_new(data, len, NULL);
+  if (!buffer) {
+    return 0;
+  }
+
+  if (!ssl_cert_append_raw_cert(cert, buffer)) {
+    return 0;
+  }
+
+  ssl_cert_flush_cached_x509_chain(cert);
+  return 1;
+}
+
 static void ssl_cert_set_cert_cb(CERT *c, int (*cb)(SSL *ssl, void *arg),
                                  void *arg) {
   c->cert_cb = cb;
@@ -1006,6 +1031,10 @@ int SSL_CTX_add1_chain_cert(SSL_CTX *ctx
   return ssl_cert_add1_chain_cert(ctx->cert, x509);
 }
 
+int SSL_CTX_add_raw_chain_cert(SSL_CTX *ctx, const uint8_t *data, size_t len) {
+  return ssl_cert_add_raw_chain_cert(ctx->cert, data, len);
+}
+
 int SSL_CTX_add_extra_chain_cert(SSL_CTX *ctx, X509 *x509) {
   return SSL_CTX_add0_chain_cert(ctx, x509);
 }
@@ -1018,6 +1047,10 @@ int SSL_add1_chain_cert(SSL *ssl, X509 *
   return ssl_cert_add1_chain_cert(ssl->cert, x509);
 }
 
+int SSL_add_raw_chain_cert(SSL *ssl, const uint8_t *data, size_t len) {
+  return ssl_cert_add_raw_chain_cert(ssl->cert, data, len);
+}
+
 int SSL_CTX_clear_chain_certs(SSL_CTX *ctx) {
   return SSL_CTX_set0_chain(ctx, NULL);
 }
diff -rupN a/ssl/ssl_rsa.c b/ssl/ssl_rsa.c
--- a/ssl/ssl_rsa.c	2017-01-28 10:13:07.446593000 +1030
+++ b/ssl/ssl_rsa.c	2017-01-28 10:39:33.910648414 +1030
@@ -72,6 +72,7 @@
 
 static int ssl_set_cert(CERT *cert, X509 *x509);
 static int ssl_set_pkey(CERT *cert, EVP_PKEY *pkey);
+static int ssl_set_raw_cert(CERT *cert, CRYPTO_BUFFER *buffer);
 
 static int is_key_type_supported(int key_type) {
   return key_type == EVP_PKEY_RSA || key_type == EVP_PKEY_EC;
@@ -85,6 +86,18 @@ int SSL_use_certificate(SSL *ssl, X509 *
   return ssl_set_cert(ssl->cert, x);
 }
 
+int SSL_use_raw_certificate(SSL *ssl, const uint8_t *data, size_t len) {
+  if (data == NULL) {
+    OPENSSL_PUT_ERROR(SSL, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  CRYPTO_BUFFER *buffer = CRYPTO_BUFFER_new(data, len, NULL);
+  if (!buffer) {
+    return 0;
+  }
+  return ssl_set_raw_cert(ssl->cert, buffer);
+}
+
 int SSL_use_certificate_ASN1(SSL *ssl, const uint8_t *der, size_t der_len) {
   if (der_len > LONG_MAX) {
     OPENSSL_PUT_ERROR(SSL, ERR_R_OVERFLOW);
@@ -188,6 +201,19 @@ int SSL_CTX_use_certificate(SSL_CTX *ctx
   return ssl_set_cert(ctx->cert, x);
 }
 
+int SSL_CTX_use_raw_certificate(SSL_CTX *ctx, const uint8_t *data,
+                                size_t len) {
+  if (data == NULL) {
+    OPENSSL_PUT_ERROR(SSL, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  CRYPTO_BUFFER *buffer = CRYPTO_BUFFER_new(data, len, NULL);
+  if (!buffer) {
+    return 0;
+  }
+  return ssl_set_raw_cert(ctx->cert, buffer);
+}
+
 static int ssl_set_cert(CERT *cert, X509 *x) {
   EVP_PKEY *pkey = X509_get_pubkey(x);
   if (pkey == NULL) {
@@ -236,6 +262,10 @@ static int ssl_set_cert(CERT *cert, X509
     return 0;
   }
 
+  return ssl_set_raw_cert(cert, buffer);
+}
+
+static int ssl_set_raw_cert(CERT *cert, CRYPTO_BUFFER *buffer) {
   ssl_cert_flush_cached_x509_leaf(cert);
 
   if (cert->chain != NULL) {
