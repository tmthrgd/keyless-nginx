diff -rupN a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
--- a/src/event/ngx_event_openssl.c	2016-04-20 01:32:38.000000000 +0930
+++ b/src/event/ngx_event_openssl.c	2016-05-01 01:48:05.016988993 +0930
@@ -13,6 +13,9 @@
 #define NGX_SSL_PASSWORD_BUFFER_SIZE  4096
 
 
+#include <ngx_keyless_module.h>
+
+
 typedef struct {
     ngx_uint_t  engine;   /* unsigned  engine:1; */
 } ngx_openssl_conf_t;
@@ -399,6 +402,47 @@ ngx_ssl_certificate(ngx_conf_t *cf, ngx_
 
     BIO_free(bio);
 
+    if (ngx_strncmp(key->data, "keyless:", sizeof("keyless:") - 1) == 0) {
+
+        u_char *addr;
+        size_t addr_len;
+        KEYLESS_CTX *ctx;
+        ngx_pool_cleanup_t *cln;
+
+        x509 = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);
+
+        addr = key->data + sizeof("keyless:") - 1;
+        addr_len = key->len - sizeof("keyless:") + 1;
+
+        ctx = keyless_parse_and_create(cf->cycle->pool, cf->cycle->log, x509,
+                                       (const char *)addr, addr_len);
+
+        if (ctx == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "keyless_parse_and_create(\"%s\") failed", addr);
+            return NGX_ERROR;
+        }
+
+        if (keyless_attach_ssl_ctx(ssl->ctx, ctx) == 0) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "keyless_attach_ssl_ctx(\"%s\") failed", addr);
+            keyless_free(ctx);
+            return NGX_ERROR;
+        }
+
+        cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);
+        if (!cln) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, "ngx_pool_cleanup_add");
+            keyless_free(ctx);
+            return NGX_ERROR;
+        }
+
+        cln->handler = (ngx_pool_cleanup_pt)keyless_free;
+        cln->data = ctx;
+
+        return NGX_OK;
+    }
+
     if (ngx_strncmp(key->data, "engine:", sizeof("engine:") - 1) == 0) {
 
 #ifndef OPENSSL_NO_ENGINE
@@ -1210,6 +1254,21 @@ ngx_ssl_handshake(ngx_connection_t *c)
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
 
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {
+        c->read->handler = ngx_ssl_handshake_handler;
+        c->write->handler = ngx_ssl_handshake_handler;
+
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
         }
